  // toy1 is an UML implementation: 2d UML fit of Higgs signal against a gg background
  //      - fixed m resolution
  //      - pT is modeled with RooHistPdf
  //      - no reference to normalization anywhere
  void   toy1(int nsg = 50, int nbg = 500); 

  // toy2 is another UML implementation: 2d UML fit of Higgs signal against a gg background
  //     - fixed m resolution
  //     - pT is modeled with RooHistPdf
  //     - extended UML
  void   toy2(int nsg = 50, int nbg = 500); 

  // toy3 is another UML implementation: 2d UML fit of contact Higgs signal against a gg+SM Higgs bg
  //     - signal is     Higgs(mtop -> infty)
  //     - background is diphoton + Higgs(mtop = 173.5GeV)
  void   toy3(int nsg = 100, double nbgH = 50, double nbg = 450); 

  // toy4 adds a sensitivity calculation
  //     - signal is     Higgs(mtop -> infty)
  //     - background is diphoton + Higgs(mtop = 173.5GeV)
  void   toy4(double nsg0 = 50, double nsg1 = 100, double nbg = 450, int ntoy = -1); 

  // toy5 introduces the delta LogLikelihood as a significance estimate using RooFit tools
  //     - extended UML for mass ONLY
  //     - signal is     Higgs(mtop -> infty)
  //     - background is diphoton + Higgs(mtop = 173.5GeV)
  void   toy5(double nsg0 = 50, double nsg1 = 100, double nbg = 450, int ntoy = 200); 

  // -- this has nothing to do with Higgs!
  void   toy6();   
  void   toy7(); 
  void   toy8(); 

  void   toy9(int nsig = 50, int nbkg = 1000); 
  void   toy10(int nsig0 = 50, int nbkg0 = 1000);

  void   toy11(int nb0 = 1000, double start = 0.2);
  void   toy12(int nb0 = 1000, double start = 0.2);



  // analysis: Everything after treeAnalysis and before toyX()
  //     - event yields in lumi
  //     - hi-pt diphoton resolution
  //     - all required histograms
  void allNumbers(int ntoy = 100); 

  // -- 1D eUML mass fit with DLL
  void allNumbers1(int ntoy = -1); 

  // -- 2D eUML mass-pT fit wtih DLL
  void allNumbers2(int ntoy = -1); 

  // -- 2D eUML mass-pT fit with LLR
  void allNumbers3(int ntoy = -1); 
  // -- 2D eUML mass-pT fit with PROFILED LLR, try the setup of 1310.1397
  void allNumbers4(int ntoy = -1); 































// ----------------------------------------------------------------------
void plotHpt::toy1(int nsg, int nbg) {

  fHistFile = TFile::Open(fHistFileName.c_str()); 

  // =======
  // -- mass
  // =======

  // -- Signal
  RooRealVar m("m", "m", 100., 150.); 
  RooRealVar meanM("meanM", "meanM", 125., 100, 150);  
  RooRealVar sigmaM("sigmaM", "sigmaM", 5., 3., 10.);  
  RooGaussian sgM("sgM", "signal mass", m, meanM, sigmaM); 

  // -- Background
  RooRealVar C0("C0", "coefficient #0", 1.0, -1., 1.); 
  RooRealVar C1("C1", "coefficient #1", 0.1, -1., 1.); 
  RooPolynomial bgM("bgM", "background mass", m, RooArgList(C0, C1)); 


  // =====
  // -- pT
  // =====

  RooRealVar pt("pt", "pt", 0., 1000); 
  RooRealVar tau("tau","tau", -0.01412, -10, -1.e-4); 
  RooExponential sgPt("sgPt", "signal pT", pt, tau);   

  RooRealVar bgTau("bgTau", "background tau", -0.019, -10, -1.e-4); 
  RooExponential bgPt("bgPt", "background pT", pt, bgTau);   

  TH1D *h1 = (TH1D*)fHistFile->Get("pt_mcatnlo_hipt")->Clone("h1");
  //  h1->Smooth();
  RooDataHist hSgPt("hSgPt", "signal histogram pT", pt, h1); 
  RooHistPdf sgHistPt("sgHistPt","signal histogam pT", pt, hSgPt, 2) ;

  h1 = (TH1D*)fHistFile->Get("pt_sherpa_hipt")->Clone("h1");
  //  h1->Smooth();
  RooDataHist hBgPt("hBgPt", "background histogram pT", pt, h1); 
  RooHistPdf bgHistPt("bgHistPt","background histogam pT", pt, hBgPt, 2) ;

  // -- determine Chebychev coefficients
  if (0) {

    // -- OLD Background
    RooRealVar C0("C0", "coefficient #0", 0.086, -1., 1.); 
    RooRealVar C1("C1", "coefficient #1", 0.006, -1., 1.); 
    RooRealVar C2("C2", "coefficient #2", 0.008, -1., 1.); 
    RooChebychev bgM("bgM", "background mass", m, RooArgList(C0, C1, C2)); 

    TH1D *h1 = (TH1D*)fHistFile->Get("m_sherpa_hipt");
    RooDataHist dataBg("data", "background mass distribution", m, h1);
    bgM.fitTo(dataBg); 
    
    RooPlot *frameBg = m.frame(); 
    dataBg.plotOn(frameBg);  
    bgM.plotOn(frameBg); 
    
    bgM.paramOn(frameBg);
    frameBg->Draw();
  }

  RooRealVar fsig("fsig", "signal fraction", 0.25, 0., 1.) ;

  RooAddPdf modelM("modelM", "model for mass", RooArgList(sgM, bgM), fsig); 
  RooAddPdf modelPt("modelPt", "model for pT", RooArgList(sgHistPt, bgHistPt), fsig) ;
  RooProdPdf model("model", "complete model", RooArgSet(modelM, modelPt)); 
  

  RooDataSet *data = model.generate(RooArgSet(m, pt), nsg+nbg);  

  sigmaM.setConstant(kTRUE);
  meanM.setConstant(kTRUE);

  C0.setRange(0.9, 1.1);
   C1.setRange(0.0, 0.2);

  model.fitTo(*data); 
  RooPlot *frameM = m.frame(); 
  data->plotOn(frameM);  
  model.plotOn(frameM); 
  model.plotOn(frameM, Components("bgM"), LineStyle(kDashed)) ;
  
  RooPlot *framePt = pt.frame();  
  data->plotOn(framePt);  
  model.plotOn(framePt); 
  model.plotOn(framePt, Components("bgHistPt"), LineStyle(kDashed)) ;


  zone(1, 2);
  frameM->Draw();
  c0->cd(2);
  gPad->SetLogy(1);
  framePt->Draw();

  fHistFile->Close();
}


// ----------------------------------------------------------------------
void plotHpt::toy2(int nsg, int nbg) {

  fHistFile = TFile::Open(fHistFileName.c_str()); 

  double ggSigma(5.0); 

  // =======
  // -- mass
  // =======

  RooRealVar nSg("nSg", "signal fraction", nsg, 0., 100*nsg);
  RooRealVar nBg("nBg", "background fraction", nbg, 0., 100.*nbg);

  // -- Signal
  RooRealVar m("m", "m", 100., 150.); 
  RooRealVar meanM("meanM", "meanM", 125., 100, 150);  
  RooRealVar sigmaM("sigmaM", "sigmaM", ggSigma, 3., 10.);  
  RooGaussian sgM("sgM", "signal mass", m, meanM, sigmaM); 
  RooExtendPdf esgM("esgM", "extended signal mass", sgM, nSg);

  // -- Background
  RooRealVar C0("C0", "coefficient #0", 1.0, -1., 2.); 
  RooRealVar C1("C1", "coefficient #1", 0.1, -1., 2.); 
  RooPolynomial bgM("bgM", "background mass", m, RooArgList(C0, C1)); 
  RooExtendPdf ebgM("ebgM", "extended background mass", bgM, nBg);
  

  // =====
  // -- pT
  // =====

  RooRealVar pt("pt", "pt", 0., 1000); 
  RooRealVar tau("tau","tau", -0.01412, -10, -1.e-4); 
  RooExponential sgPt("sgPt", "signal pT", pt, tau);   
  RooExtendPdf esgPt("esgPt", "extended signal pT", sgPt, nSg); 

  RooRealVar bgTau("bgTau", "background tau", -0.019, -10, 0.); 
  RooExponential bgPt("bgPt", "background pT", pt, bgTau);   

  //  TH1D *h1 = (TH1D*)fHistFile->Get("pt_mcatnlo_hipt")->Clone("h1");
  TH1D *h1 = (TH1D*)fHistFile->Get("pt_mcatnlo5_hipt")->Clone("h1");
  RooDataHist hSgPt("hSgPt", "signal histogram pT", pt, h1); 
  RooHistPdf sgHistPt("sgHistPt","signal histogam pT", pt, hSgPt, 2) ;
  //  RooExtendPdf esgHistPt("esgHistPt", "extended signal histogram pT", sgHistPt, nSg); 

  TH1D *h2 = (TH1D*)fHistFile->Get("pt_sherpa_hipt")->Clone("h2");
  RooDataHist hBgPt("hBgPt", "background histogram pT", pt, h2); 
  RooHistPdf bgHistPt("bgHistPt","background histogam pT", pt, hBgPt, 2) ;
  //  RooExtendPdf ebgHistPt("ebgHistPt", "extended background histogram pT", bgHistPt, nBg); 

  RooAddPdf modelM("modelM", "model for mass", RooArgList(sgM, bgM), RooArgList(nSg, nBg)); 
  //  RooAddPdf modelPt("modelPt", "model for pT", RooArgList(sgHistPt, bgHistPt), RooArgList(nSg, nBg));
  RooAddPdf modelPt("modelPt", "model for pT", RooArgList(sgPt, bgPt), RooArgList(nSg, nBg));
  RooProdPdf model("model", "complete model", RooArgSet(modelM, modelPt)); 
  
  //  RooDataSet *data = model.generate(RooArgSet(m, pt), nsg+nbg);  
  RooDataSet *data = model.generate(RooArgSet(m, pt));  

  sigmaM.setConstant(kTRUE);
  meanM.setConstant(kTRUE);

  C0.setRange(0.9, 1.1);
  C1.setRange(0.0, 0.2);

  model.fitTo(*data, Extended(kTRUE)); 
  RooPlot *frameM = m.frame(); 
  data->plotOn(frameM);  
  model.plotOn(frameM); 
  model.plotOn(frameM, Components("bgM"), LineStyle(kDashed)) ;
  
  RooPlot *framePt = pt.frame();  
  data->plotOn(framePt);  
  model.plotOn(framePt); 
  model.plotOn(framePt, Components("bgHistPt"), LineStyle(kDashed)) ;


  zone(2, 2);
  frameM->Draw();
  c0->cd(2);
  gPad->SetLogy(1);
  h1->SetLineColor(kBlue);
  h2->SetLineColor(kRed);
  h1->Draw(); 
  h2->Draw("same"); 
  c0->cd(3);
  gPad->SetLogy(0);
  framePt->Draw();
  c0->cd(4);
  gPad->SetLogy(1);
  framePt->Draw();

  fHistFile->Close();
}


// ----------------------------------------------------------------------
void plotHpt::toy3(int nsg0, double nsg1, double  nbg) {

  fHistFile = TFile::Open(fHistFileName.c_str()); 

  // -- determine function parameters
  if (0) { 
    double xmin(300.), xmax(1000.); 
    gStyle->SetOptStat(0); 
    gStyle->SetOptFit(111); 
    zone(2,2);
    TH1D *h1 = (TH1D*)fHistFile->Get("m_sherpa_hipt")->Clone("h1");
    //    h1->Scale(1./h1->GetSumOfWeights()); 
    h1->SetMinimum(0.);
    h1->Fit("pol1"); 
    h1->GetFunction("pol1")->SetLineWidth(2); 

    c0->cd(2);
    gPad->SetLogy(1);
    TH1D *h2 = (TH1D*)fHistFile->Get("pt_sherpa_hipt")->Clone("h2");
    //    h2->Scale(1./h2->GetSumOfWeights()); 
    h2->SetTitle("Sherpa gg"); 
    h2->Fit("expo", "rl", "", xmin, xmax); 
    h2->GetFunction("expo")->SetLineWidth(2); 

    c0->cd(3);
    gPad->SetLogy(1);
    TH1D *h3 = (TH1D*)fHistFile->Get("pt_mcatnlo5_hipt")->Clone("h3");
    //    h3->Scale(1./h3->GetSumOfWeights()); 
    h3->SetTitle("m(top) #rightarrow #infty"); 
    h3->Fit("expo", "rl", "", xmin, xmax); 
    h3->GetFunction("expo")->SetLineWidth(2); 

    c0->cd(4);
    gPad->SetLogy(1);
    TH1D *h4 = (TH1D*)fHistFile->Get("pt_mcatnlo_hipt")->Clone("h4");
    //    h4->Scale(1./h4->GetSumOfWeights()); 
    h4->SetTitle("m(top) = 173.5 GeV"); 
    h4->Fit("expo", "rl", "", xmin, xmax); 
    h4->GetFunction("expo")->SetLineWidth(2); 

    //  ****************************************
    //  Minimizer is Linear
    //  Chi2                      =      14.1314
    //  NDf                       =           23
    //  p0                        =      166.971   +/-   28.4753     
    //  p1                        =     0.837631   +/-   0.227452    

    //  NORMALIZED TO 1:
    //  ****************************************
    //  Minimizer is Linear
    //  Chi2                      =   0.00207631
    //  NDf                       =           23
    //  p0                        =    0.0245329   +/-   0.345162    
    //  p1                        =  0.000123072   +/-   0.00275705  
   
    //  SHERPA
    //  FCN=80.7532 FROM MIGRAD    STATUS=CONVERGED      83 CALLS          84 TOTAL
    //                      EDM=1.57571e-10    STRATEGY= 1      ERROR MATRIX ACCURATE
    //   EXT PARAMETER                                   STEP         FIRST
    //   NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE
    //    1  Constant     1.05700e+01   6.00323e-02   7.54946e-05   8.85296e-04
    //    2  Slope       -1.26957e-02   1.55210e-04   1.95185e-07   3.77248e-01
    //                                ERR DEF= 0.5
    //  m(top) -> infty
    //  FCN=44.2806 FROM MIGRAD    STATUS=CONVERGED      42 CALLS          43 TOTAL
    //                      EDM=8.07575e-08    STRATEGY= 1      ERROR MATRIX ACCURATE
    //   EXT PARAMETER                                   STEP         FIRST
    //   NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE
    //    1  Constant     8.84227e+00   4.01906e-02   5.02440e-05   1.74232e-02
    //    2  Slope       -7.81368e-03   9.10171e-05   1.13778e-07   9.73403e+00
    //                                ERR DEF= 0.5
    // m(top) = 173.5 GeV
    //  FCN=35.0345 FROM MIGRAD    STATUS=CONVERGED      70 CALLS          71 TOTAL
    //                      EDM=2.92507e-12    STRATEGY= 1      ERROR MATRIX ACCURATE
    //   EXT PARAMETER                                   STEP         FIRST
    //   NO.   NAME      VALUE            ERROR          SIZE      DERIVATIVE
    //    1  Constant     9.45657e+00   6.72258e-02   6.20582e-05   1.01431e-04
    //    2  Slope       -1.09325e-02   1.67445e-04   1.54573e-07   4.42596e-02
    //                                ERR DEF= 0.5
    return;
  }




  // mass
  // ====
  
  // -- Signal
  RooRealVar m("m", "m", 100., 150.); 
  RooRealVar sgP("sgP", "signal peak mass", 125., 100, 150);  
  sgP.setConstant(kTRUE);
  RooRealVar sgS("sgS", "signal sigma mass", 10., 5., 15.);  
  sgS.setConstant(kTRUE);
  RooGaussian sg0M("sg0M", "signal mass", m, sgP, sgS); 
  RooGaussian sg1M("sg1M", "signal mass", m, sgP, sgS); 

  // -- Background
  double bgc0  = 0.0245329;
  double bgc0e = 0.00418385;  // derived from the normalized unscaled fit! 
  RooRealVar C0("C0", "coefficient #0", bgc0, -1., 1.); 
  //  C0.setRange(bgc0 - bgc0e, bgc0 + bgc0e);
  //   double bgc1  = 0.0001231;
  //   double bgc1e = 3.341922e-5; // derived from the normalized unscaled fit! 
  //   RooRealVar C1("C1", "coefficient #1", bgc1, -1., 1.); 
  //  C1.setRange(bgc1 - bgc1e, bgc1 + bgc1e);
  RooPolynomial bg0M("bg0M", "background 0 gamma gamma mass", m, RooArgList(C0)); 
  RooPolynomial bg1M("bg1M", "background 1 gamma gamma mass", m, RooArgList(C0)); 


  // pT
  // ==
  RooRealVar pt("pt", "pt", 300., 1000.); 
  // -- SM Higgs
  double sg0tau  = -1.09325e-02; 
  double sg0taue = 1.67445e-04;
  RooRealVar sg0Tau("sg0Tau", "signal 0 tau", sg0tau, -10., 10.); 
  sg0Tau.setRange(sg0tau - sg0taue, sg0tau + sg0taue); 
  RooExponential sg0Pt("sg0Pt", "signal 0 pT", pt, sg0Tau);   

  // -- "contact" Higgs
  double sg1tau  = -7.81368e-03; 
  double sg1taue = 9.10171e-05;
  RooRealVar sg1Tau("sg1Tau", "signal 1 tau", sg1tau, -10., 10.); 
  sg1Tau.setRange(sg1tau - sg1taue, sg1tau + sg1taue); 
  RooExponential sg1Pt("sg1Pt", "signal 1 pT", pt, sg1Tau);   


  double bgtau  = -1.26957e-02; 
  double bgtaue = 1.55210e-04; 
  RooRealVar bgTau("bgTau", "background gamma gamma tau", bgtau, -10., 10.); 
  //  bg0Tau.setRange(bg0tau - bg0taue, bg0tau + bg0taue); 
  RooExponential bg0Pt("bg0Pt", "background 0 gamma gamma pT", pt, bgTau);   
  RooExponential bg1Pt("bg1Pt", "background 1 gamma gamma pT", pt, bgTau);   


  RooRealVar sg0frac("sg0frac","fraction of Higgs 0 signal", nsg0/nbg, 0., 1.);
  RooRealVar sg1frac("sg1frac","fraction of Higgs 1 signal", nsg1/nbg, 0., 1.);
  RooAddPdf model0M("model0M", "model 0 for mass", RooArgList(sg0M, bg0M), sg0frac);
  RooAddPdf model0Pt("model0Pt", "model 0 for pT", RooArgList(sg0Pt, bg0Pt), sg0frac);

  RooAddPdf model1M("model1M", "model 1 for mass", RooArgList(sg1M, bg1M), sg1frac);
  RooAddPdf model1Pt("model1Pt", "model 1 for pT", RooArgList(sg1Pt, bg1Pt), sg1frac);
  
  RooProdPdf model0("model0", "complete model 0", RooArgSet(model0M, model0Pt)); 
  RooProdPdf model1("model1", "complete model 1", RooArgSet(model1M, model1Pt)); 
  RooDataSet *data0 = model0.generate(RooArgSet(m, pt), nsg0 + nbg);  
  RooDataSet *data1 = model1.generate(RooArgSet(m, pt), nsg1 + nbg);  

  cout << "XXXXX initial signal fractions, 0 = " << sg0frac.getVal() 
       << ", 1 = " << sg1frac.getVal() 
       << endl;


  RooFitResult *resData0Model0 = model0.fitTo(*data0, Save()); 
  RooPlot *f0M = m.frame(); 
  data0->plotOn(f0M);  
  model0.plotOn(f0M); 
  model0.plotOn(f0M, Components("bg0M"), LineStyle(kDashed)) ;
  
  RooPlot *f0Pt = pt.frame();  
  data0->plotOn(f0Pt);  
  model0.plotOn(f0Pt); 
  model0.plotOn(f0Pt, Components("bg0Pt"), LineStyle(kDashed)) ;

  RooFitResult *resData0Model1 = model1.fitTo(*data0, Save()); 
  RooPlot *f1M = m.frame(); 
  data0->plotOn(f1M);  
  model1.plotOn(f1M); 
  model1.plotOn(f1M, Components("bg1M"), LineStyle(kDashed)) ;
  
  RooPlot *f1Pt = pt.frame();  
  data0->plotOn(f1Pt);  
  model1.plotOn(f1Pt); 
  model1.plotOn(f1Pt, Components("bg1Pt"), LineStyle(kDashed)) ;


  zone(2, 2);
  f0M->Draw();
  c0->cd(2);
  gPad->SetLogy(1);
  f0Pt->Draw();

  c0->cd(3);
  f1M->Draw();
  c0->cd(4);
  gPad->SetLogy(1);
  f1Pt->Draw();

  c0->SaveAs("toy3-data0.pdf");


  RooFitResult *resData1Model1 =  model1.fitTo(*data1, Save()); 
  RooPlot *g1M = m.frame(); 
  data1->plotOn(g1M);  
  model1.plotOn(g1M); 
  model1.plotOn(g1M, Components("bg1M"), LineStyle(kDashed)) ;
  
  RooPlot *g1Pt = pt.frame();  
  data1->plotOn(g1Pt);  
  model1.plotOn(g1Pt); 
  model1.plotOn(g1Pt, Components("bg1Pt"), LineStyle(kDashed)) ;

  RooFitResult *resData1Model0 = model0.fitTo(*data1, Save()); 
  RooPlot *g0M = m.frame(); 
  data1->plotOn(g0M);  
  model0.plotOn(g0M); 
  model0.plotOn(g0M, Components("bg0M"), LineStyle(kDashed)) ;
  
  RooPlot *g0Pt = pt.frame();  
  data1->plotOn(g0Pt);  
  model0.plotOn(g0Pt); 
  model0.plotOn(g0Pt, Components("bg0Pt"), LineStyle(kDashed)) ;


  zone(2, 2);
  g1M->Draw();
  c0->cd(2);
  gPad->SetLogy(1);
  g1Pt->Draw();

  c0->cd(3);
  g0M->Draw();
  c0->cd(4);
  gPad->SetLogy(1);
  g0Pt->Draw();

  cout << "Fitting model 0 on data 0" << endl;
  resData0Model0->Print("v");
  cout << "Fitting model 1 on data 0" << endl;
  resData0Model1->Print("v");

  cout << "Fitting model 0 on data 1" << endl;
  resData1Model0->Print("v");
  cout << "Fitting model 1 on data 1" << endl;
  resData1Model1->Print("v");

  c0->SaveAs("toy3-data1.pdf");

  fHistFile->Close(); 

}


// ----------------------------------------------------------------------
void plotHpt::toy4(double nsg0, double nsg1, double nbg, int ntoy) {

  if (ntoy > 0) fNtoy = ntoy; 

  fHistFile = TFile::Open(fHistFileName.c_str()); 

  int NBINS(10); 

  // mass
  // ====
  
  // -- Signal
  RooRealVar m("m", "m", 100., 150., "GeV"); 
  RooRealVar sgP("sgP", "signal peak mass", 125., 100, 150);  
  sgP.setConstant(kTRUE);
  RooRealVar sgS("sgS", "signal sigma mass", fHiggsMres, 0., 15.);  
  sgS.setConstant(kTRUE);
  RooGaussian sg0M("sg0M", "signal mass", m, sgP, sgS); 
  RooGaussian sg1M("sg1M", "signal mass", m, sgP, sgS); 

  // -- Background
  double bgc0  = 0.0245329; // FIXME!!!
  //  double bgc0e = 0.00418385;  // derived from the normalized unscaled fit! 
  RooRealVar C0("C0", "coefficient #0", bgc0, -1., 1.); 
  //  C0.setRange(bgc0 - bgc0e, bgc0 + bgc0e);
  //   double bgc1  = 0.0001231;
  //   double bgc1e = 3.341922e-5; // derived from the normalized unscaled fit! 
  //   RooRealVar C1("C1", "coefficient #1", bgc1, -1., 1.); 
  //  C1.setRange(bgc1 - bgc1e, bgc1 + bgc1e);
  RooPolynomial bg0M("bg0M", "background 0 gamma gamma mass", m, RooArgList(C0)); 
  RooPolynomial bg1M("bg1M", "background 1 gamma gamma mass", m, RooArgList(C0)); 


  // pT
  // ==
  RooRealVar pt("pt", "pt", 300., 1000., "GeV"); 
  //  SM Higgs count:           17.2289 fitted exponential slope = -0.0108046+/-0.000305826
  // -- SM Higgs
  //  double sg0tau  = -1.09325e-02; // FIXME!!!
  double sg0tau = fSg0Tau; 
  //  double sg0taue = 1.67445e-04;
  double sg0taue = fSg0TauE;
  RooRealVar sg0Tau("sg0Tau", "signal 0 tau", sg0tau, -10., 10.); 
  sg0Tau.setRange(sg0tau - sg0taue, sg0tau + sg0taue); 
  RooExponential sg0Pt("sg0Pt", "signal 0 pT", pt, sg0Tau);   

  //  Contact Higgs count:      45.3107 fitted exponential slope = -0.00707933+/-0.000137285
  // -- "contact" Higgs
  //  double sg1tau  = -7.81368e-03; // FIXME!!!
  double sg1tau = fSg1Tau; 
  //  double sg1taue = 9.10171e-05;
  double sg1taue = fSg1TauE;
  RooRealVar sg1Tau("sg1Tau", "signal 1 tau", sg1tau, -10., 10.); 
  sg1Tau.setRange(sg1tau - sg1taue, sg1tau + sg1taue); 
  RooExponential sg1Pt("sg1Pt", "signal 1 pT", pt, sg1Tau);   

  //  SHERPA background:        168.859 fitted exponential slope = -0.0113285+/-0.000262761
  //  double bgtau  = -1.26957e-02; // FIXME!!!
  double bgtau = fBgTau; 
  //  double bgtaue = 1.55210e-04; 
  RooRealVar bgTau("bgTau", "background gamma gamma tau", bgtau, -10., 10.); 
  RooExponential bg0Pt("bg0Pt", "background 0 gamma gamma pT", pt, bgTau);   
  RooExponential bg1Pt("bg1Pt", "background 1 gamma gamma pT", pt, bgTau);   


  RooRealVar sg0frac("sg0frac","fraction of Higgs 0 signal", nsg0/nbg, 0., 1.);
  RooRealVar sg1frac("sg1frac","fraction of Higgs 1 signal", nsg1/nbg, 0., 1.);
  RooAddPdf model0M("model0M", "model 0 for mass", RooArgList(sg0M, bg0M), sg0frac);
  RooAddPdf model0Pt("model0Pt", "model 0 for pT", RooArgList(sg0Pt, bg0Pt), sg0frac);

  RooAddPdf model1M("model1M", "model 1 for mass", RooArgList(sg1M, bg1M), sg1frac);
  RooAddPdf model1Pt("model1Pt", "model 1 for pT", RooArgList(sg1Pt, bg1Pt), sg1frac);
  
  RooProdPdf model0("model0", "complete model 0", RooArgSet(model0M, model0Pt)); 
  RooProdPdf model1("model1", "complete model 1", RooArgSet(model1M, model1Pt)); 

  // -- alternative way to assemble data sets
  RooProdPdf modelBg("modelBg", "complete background model", RooArgSet(bg0M, bg0Pt)); 
  RooProdPdf model0Sg("model0Sg", "complete signal model 0", RooArgSet(sg0M, sg0Pt)); 
  RooProdPdf model1Sg("model1Sg", "complete signal model 1", RooArgSet(sg1M, sg1Pt)); 

//   RooDataSet *data0 = model0.generate(RooArgSet(m, pt), nsg0 + nbg);  
//   RooDataSet *data1 = model1.generate(RooArgSet(m, pt), nsg1 + nbg);  

  RooDataSet *bg0 = modelBg.generate(RooArgSet(m, pt), nbg);  
  RooDataSet *data0 = new RooDataSet(*bg0); 
  RooDataSet *data1 = new RooDataSet(*data0); 

  RooDataSet *s0 = model0Sg.generate(RooArgSet(m, pt), nsg0);  
  RooDataSet *s1 = model1Sg.generate(RooArgSet(m, pt), nsg1);  
  data0->append(*s0); 
  data1->append(*s1); 


  TVirtualPad *pad = gPad; 
  makeCanvas(1); 
  zone(2,2, c1);
  
  RooPlot *f0M = m.frame(); 
  f0M->SetTitle("m(top) = 173.5 GeV");
  data0->plotOn(f0M, Binning(NBINS));  
  model0.plotOn(f0M); 
  model0.plotOn(f0M, Components("bg0M"), LineStyle(kDashed)) ;
  model0.paramOn(f0M, Layout(0.15, 0.85)) ;
  f0M->Draw();

  c1->cd(2);
  RooPlot *a = m.frame(); 
  a->SetTitle("signal (blue) and background (red) for m(top) = 173.5 GeV");
  s0->plotOn(a, Binning(NBINS), LineColor(kBlue), MarkerColor(kBlue));  
  bg0->plotOn(a, Binning(NBINS), LineColor(kRed), MarkerColor(kRed)); 
  a->Draw();

  c1->cd(4);
  RooPlot *a1 = m.frame(); 
  a1->SetTitle("signal (blue) and background (red) for m(top) #rightarrow #infty");
  s1->plotOn(a1, Binning(NBINS), LineColor(kBlue), MarkerColor(kBlue));  
  bg0->plotOn(a1, Binning(NBINS), LineColor(kRed), MarkerColor(kRed)); 
  a1->Draw();
  
  double bExpected(0.), bExpectedRelE(0.), sExpected(0.), sExpectedRelE(0.); 
  double zExp(0.); 

  // -- now setup toy loop
  RooCmdArg fitargs; 
  if (1) {
  fitargs.addArg(Minos(kTRUE)); 
  fitargs.addArg(PrintLevel(-1));
  fitargs.addArg(PrintEvalErrors(-1));
  fitargs.addArg(Verbose(kFALSE));
  fitargs.addArg(Save()); 
  fitargs.addArg(Minimizer("Minuit2")); 
  }
  TH1D *h1z = new TH1D("h1z", " ", 100, 0., 10.); 
  TH1D *h1zTh = new TH1D("h1zTh", "significance wrt theory expectation", 100, 0., 10.); 
  TH1D *h1zZero = new TH1D("h1zZero", "significance wrt zero expectation ", 100, 0., 10.); 
  RooFitResult *fr0(0), *fr1(0); 
  zone(2, 1, c1);
  double zExpTh(0.); 
  double zExpZero(0.); 
  for (int imc = 0; imc < fNtoy; ++imc) {
    data0->reset();
    data1->reset();
    cout << "==> starting run " << imc << endl;
    C0.setVal(bgc0);
    bgTau.setVal(bgtau);

    sg0Tau.setVal(sg0tau);
    sg0frac.setVal(nsg0/nbg);

    sg1Tau.setVal(sg1tau);
    sg1frac.setVal(nsg1/nbg);

    if (0) {
      modelBg.Print("t");
      model0Sg.Print("t");
      model1Sg.Print("t");
    }

    bg0 = modelBg.generate(RooArgSet(m, pt), nbg);  
    s0 = model0Sg.generate(RooArgSet(m, pt), nsg0);  
    s1 = model1Sg.generate(RooArgSet(m, pt), nsg1);  
    
    data0->append(*bg0); 
    data0->append(*s0); 

    data1->append(*bg0); 
    data1->append(*s1); 

    cout << "----------------------------------------------------------------------" << endl;
    cout << "Fit model 0 to data 0, toy = " << imc << endl;
    cout << "----------------------------------------------------------------------" << endl;
    fr0 = model0.fitTo(*data0, fitargs); 
    cout << "----------------------------------------------------------------------" << endl;
    cout << "Fit model 1 to data 1" << endl;
    cout << "----------------------------------------------------------------------" << endl;
    fr1 = model1.fitTo(*data1, fitargs); 

    bExpected     = sg0frac.getVal()*data0->numEntries();
    bExpectedRelE = sg0frac.getError()/sg0frac.getVal();

    sExpected     = sg1frac.getVal()*data1->numEntries();
    sExpectedRelE = sg1frac.getError()/sg1frac.getVal();
 
    int reset(0); 
    if (0 && bExpected < 1.) {
      reset = 1; 
      bExpected = 2.3; 
      bExpectedRelE = 0.99;
    }

    if (sg0frac.getVal() < sg0frac.getError()) {
      bExpected = nsg0; 
      bExpectedRelE = TMath::Sqrt(nsg0)/nsg0; 
    }
    
    zExp = NumberCountingUtils::BinomialExpZ(sExpected, bExpected, bExpectedRelE);
    zExpTh = NumberCountingUtils::BinomialExpZ(sExpected, nsg0, TMath::Sqrt(nsg0)/nsg0);
    zExpZero = NumberCountingUtils::BinomialExpZ(sExpected, 2.3, 0.99);
    cout << Form("%3d zExp = %5.4f from bExpected = %4.1f+/-%4.1f and sExpected = %4.1f (reset = %d, zExpTh = %4.1f, zExpZero = %4.1f)", 
		 imc, zExp, bExpected, bExpected*bExpectedRelE, sExpected, reset, zExpTh, zExpZero) 
	 << endl;
    if (zExp < 0) {
      --imc;
      continue;
    }

    h1z->Fill(zExp); 
    h1zTh->Fill(zExpTh); 
    h1zZero->Fill(zExpZero); 

    if (0 && zExp < 0.1) {
      RooPlot *g0M = m.frame(); 
      g0M->SetTitle("m(top) = 173.5GeV");
      data0->plotOn(g0M, Binning(NBINS));  
      model0.plotOn(g0M); 
      model0.plotOn(g0M, Components("bg0M"), LineStyle(kDashed)) ;
      c1->cd(1);
      model0.paramOn(g0M, Layout(0.15, 0.85)) ;
      g0M->Draw();

      RooPlot *g1M = m.frame(); 
      g1M->SetTitle("m(top) #rightarrow #infty");
      data1->plotOn(g1M, Binning(NBINS));  
      model1.plotOn(g1M); 
      model1.plotOn(g1M, Components("bg1M"), LineStyle(kDashed)) ;
      c1->cd(2);
      model1.paramOn(g1M, Layout(0.15, 0.85)) ;
      g1M->Draw();
      tl->SetNDC(kTRUE);
      tl->DrawLatex(0.2, 0.2, Form("zExp = %4.3f", zExp)); 
      tl->DrawLatex(0.2, 0.15, Form("S = %4.1f, B = %4.1f +/- %4.1f", sExpected, bExpected, bExpectedRelE*bExpected)); 
      c1->SaveAs(Form("%s/toy4-%s-%d.pdf", fDirectory.c_str(), fSetup.c_str(), imc)); 
    }
  }
  pad->cd();
  gStyle->SetOptStat(0); 
  h1z->Draw();
  tl->SetTextColor(kBlack); 
  tl->DrawLatex(0.6, 0.80, Form("Mean = %4.3f", h1z->GetMean())); 
  tl->DrawLatex(0.6, 0.75, Form("RMS = %4.3f", h1z->GetRMS())); 
  tl->DrawLatex(0.6, 0.70, Form("Mean(TH) =  %4.3f", h1zTh->GetMean())); 
  tl->DrawLatex(0.6, 0.65, Form("Mean(zero) =  %4.3f", h1zZero->GetMean())); 
  tl->DrawLatex(0.6, 0.92, Form("Setup: %s", fSetup.c_str())); 
  fHistFile->Close();

  fTEX.open(fTexFileName.c_str(), ios::app);
  fTEX << formatTex(h1z->GetMean(), Form("%s:zexp:val", fSetup.c_str()), 2) << endl;
  fTEX << formatTex(h1z->GetRMS(), Form("%s:zexp:rms", fSetup.c_str()), 2) << endl;
  fTEX << formatTex(h1zTh->GetMean(), Form("%s:zexpTh:val", fSetup.c_str()), 2) << endl;
  fTEX << formatTex(h1zTh->GetRMS(), Form("%s:zexpTh:rms", fSetup.c_str()), 2) << endl;
  fTEX << formatTex(h1zZero->GetMean(), Form("%s:zexpZero:val", fSetup.c_str()), 2) << endl;
  fTEX << formatTex(h1zZero->GetRMS(), Form("%s:zexpZero:rms", fSetup.c_str()), 2) << endl;
  fTEX.close();
}

// ----------------------------------------------------------------------
void plotHpt::toy5(double nsg0, double nsg1, double nbg, int ntoy) {

  fHistFile = TFile::Open(fHistFileName.c_str()); 

  if (ntoy > 0) fNtoy = ntoy; 

  int NBINS(11); 

  // mass
  // ====
  
  // -- Signal
  RooRealVar m("m", "m", MGGLO, MGGHI, "GeV"); 
  RooRealVar sgP("sgP", "signal peak mass", 125., MGGLO, MGGHI);  
  sgP.setConstant(kTRUE);
  RooRealVar sgS("sgS", "signal sigma mass", fHiggsMres, 0., 15.);  
  sgS.setConstant(kTRUE);
  RooGaussian sg0M("sg0M", "signal mass", m, sgP, sgS); 
  RooGaussian sg1M("sg1M", "signal mass", m, sgP, sgS); 

  // -- Background
  double bgc0  = 0.0245329; // FIXME!!!
  //  double bgc0e = 0.00418385;  // derived from the normalized unscaled fit! 
  RooRealVar C0("C0", "coefficient #0", bgc0, -1., 1.); 
  //  C0.setRange(bgc0 - bgc0e, bgc0 + bgc0e);
  //   double bgc1  = 0.0001231;
  //   double bgc1e = 3.341922e-5; // derived from the normalized unscaled fit! 
  //   RooRealVar C1("C1", "coefficient #1", bgc1, -1., 1.); 
  //  C1.setRange(bgc1 - bgc1e, bgc1 + bgc1e);
  RooPolynomial bg0M("bg0M", "background 0 gamma gamma mass", m, RooArgList(C0)); 
  RooPolynomial bg1M("bg1M", "background 1 gamma gamma mass", m, RooArgList(C0)); 

  RooRealVar sg0N("sg0N","Number of Higgs 0 signal events", nsg0, 0., 1.e4);
  RooRealVar sg1N("sg1N","Numberof Higgs 1 signal events", nsg1, 0., 1.e4);
  RooRealVar bgN("bgN","Number of background events", nbg, 0., 1.e5);

  RooAddPdf model0("model0M", "model 0 for mass", RooArgList(sg0M, bg0M), RooArgList(sg0N, bgN));
  RooAddPdf model1("model1M", "model 1 for mass", RooArgList(sg1M, bg1M), RooArgList(sg1N, bgN));

 
  RooDataSet *data1 = model1.generate(m, nbg+nsg0); 


//   FrequentistCalculator *fc  = new FrequentistCalculator(*data1, &model1, &model0);
//   fc->SetToys(100, 100);    // 1000 for null (B) and 1000 for alt (S+B) 
    
//     // create the test statistics
//   ProfileLikelihoodTestStat profll(*model1->GetPdf());
//   // use one-sided profile likelihood
//   profll.SetOneSidedDiscovery(true);
  
//   // configure  ToyMCSampler and set the test statistics
//   ToyMCSampler *toymcs = (ToyMCSampler*)fc->GetTestStatSampler();
//   toymcs->SetTestStatistic(&profll);
  
//   if (!model1->GetPdf()->canBeExtended())
//     toymcs->SetNEventsPerToy(1);
  
//   // run the test
//   HypoTestResult * r = fc->GetHypoTest();
//   r->Print();
  
//   // plot test statistic distributions
//   HypoTestPlot * plot = new HypoTestPlot(*r);
//   plot->Draw();





  RooMCStudy* mcstudy = new RooMCStudy(model1, m, Binned(), Silence(), Extended(kTRUE),
				       FitOptions(Save(kTRUE), Extended(kTRUE), PrintEvalErrors(-1))
				       );

  //  RooDLLSignificanceMCSModule sigModule(sg1N, nsg0);

  double nullHypo = nsg0; 
  RooDLLSignificanceMCSModule sigModule(sg1N, nullHypo);
  mcstudy->addModule(sigModule);

  // Generate and fit 1000 samples of Poisson(nExpected) events
  mcstudy->generateAndFit(1000);

  TH1 *hdll = mcstudy->fitParDataSet().createHistogram("dll_nullhypo_sg1N",-40,-40) ;
  TH1 *hz = mcstudy->fitParDataSet().createHistogram("significance_nullhypo_sg1N",-40,-40) ;

  RooPlot* frame1 = mcstudy->plotParam(sg1N, Bins(40)) ;
  RooPlot* frame2 = mcstudy->plotError(sg1N, Bins(40)) ;
  RooPlot* frame3 = mcstudy->plotPull(sg1N, Bins(40), FitGauss(kTRUE)) ;

  RooPlot* frame4 = mcstudy->plotNLL(Bins(40)) ;

  gStyle->SetPalette(1) ;
  gStyle->SetOptStat(0) ;
  makeCanvas(4); 
  c3->Divide(2,3) ;

  c3->cd(1) ; gPad->SetLeftMargin(0.15) ; frame1->GetYaxis()->SetTitleOffset(1.4) ; frame1->Draw() ;
  c3->cd(2) ; gPad->SetLeftMargin(0.15) ; frame2->GetYaxis()->SetTitleOffset(1.4) ; frame2->Draw() ;
  c3->cd(3) ; gPad->SetLeftMargin(0.15) ; frame3->GetYaxis()->SetTitleOffset(1.4) ; frame3->Draw() ;
  c3->cd(4) ; gPad->SetLeftMargin(0.15) ; frame4->GetYaxis()->SetTitleOffset(1.4) ; frame4->Draw() ;


  c3->cd(5) ; gPad->SetLeftMargin(0.15) ; hdll->GetYaxis()->SetTitleOffset(1.6) ; hdll->Draw("") ;
  c3->cd(6) ; gPad->SetLeftMargin(0.15) ; hz->GetYaxis()->SetTitleOffset(1.6) ; hz->Draw("") ;
  
  tl->SetNDC(kTRUE);
  tl->SetTextColor(kBlack);
  tl->SetTextSize(0.05);
  tl->DrawLatex(0.2, 0.8, Form("Null Hypo: %4.0f", nullHypo)); 
  tl->DrawLatex(0.2, 0.7, Form("Mean: %4.3f +/- %4.3f", hz->GetMean(), hz->GetRMS())); 
  

  c3->SaveAs("c3.pdf");

  return;
}



// ----------------------------------------------------------------------
void plotHpt::toy6() {
  // based on https://twiki.cern.ch/twiki/bin/view/Main/LearningRoostats
  
  //construct the model
  RooWorkspace w("w");
  
  w.factory("Gaussian::constraint_b(nuisance_b[41.7,0,100],41.7,4.6)"); //constrained b to be positive - "truncated gaussian"
  w.factory("Gaussian::constraint_acc(nuisance_acc[0.71,0,1],0.71,0.09)"); //constrained acc in range 0-1
  w.factory("Gaussian::constraint_lumi(nuisance_lumi[5.0,0.0,10.0],5.0,0.195)"); //constrained lumi from 0 to 10.0
  w.factory("prod::s(sigma[0,100],nuisance_lumi,nuisance_acc)"); //constructs a function
  w.factory("sum::mean(s,nuisance_b)"); //another function
  w.factory("Poisson::pois(n[61,0,100],mean)"); //a pdf (special function)
  w.factory("PROD::model(pois,constraint_b,constraint_lumi,constraint_acc)"); //another pdf
  
  //define RooArgSets for convenience
  w.defineSet("obs","n"); //observables
  w.defineSet("poi","sigma"); //parameters of interest
  w.defineSet("np","nuisance_b,nuisance_lumi,nuisance_acc"); //nuisance parameters
  
  RooDataSet data("data", "data", *w.set("obs"));
  data.add(*w.set("obs")); //actually add the data
  
  
  cout << "xxxxx > create nll" << endl;
  RooAbsReal* nll = w.pdf("model")->createNLL(data);
  
  
  RooPlot* frame = w.var("sigma")->frame(Range(0., 12.));
  nll->plotOn(frame, ShiftToZero()); //the ShiftToZero option puts the minimum at 0 on the y-axis
  frame->Draw();
  
  if (1) {
    cout << "xxxxx > create pll" << endl;
    RooAbsReal* pll = nll->createProfile(*w.set("poi"));
    pll->plotOn(frame,LineColor(kRed));
    frame->Draw();
  }

  if (1) {
    RooMinuit mini(*nll);
    mini.minos(*w.set("poi")); //could give no arg list and it will calculate minos errors for all the parameters
  
    RooFitResult* res = mini.save("myResult","My Result");
    res->status(); //should be 0 for success!
  }
  
  TLine l; 
  
  l.DrawLine(w.var("sigma")->getVal()+w.var("sigma")->getErrorLo(),0,w.var("sigma")->getVal()+w.var("sigma")->getErrorLo(),0.5);
  l.DrawLine(w.var("sigma")->getVal()+w.var("sigma")->getErrorHi(),0,w.var("sigma")->getVal()+w.var("sigma")->getErrorHi(),0.5);
  l.DrawLine(0., 0.5, 12., 0.5);
  
  cout << "xxxxx > nll: " << endl;
  nll->Print("tv");
  cout << "xxxxx > nll_model_data: " << endl;
  nll->getComponents()->find("nll_model_data")->Print("v");
  cout << "xxxxx > nll_model_data_constr: " << endl;
  nll->getComponents()->find("nll_model_data_constr")->Print("v");
  cout << "xxxxx > sigma: " << endl;
  w.var("sigma")->Print("v");
  cout << "xxxxx > nuisance_b: " << endl;
  w.var("nuisance_b")->Print("v");

}


// ----------------------------------------------------------------------
void plotHpt::toy7() {

  // based on https://twiki.cern.ch/twiki/bin/view/Main/LearningRoostats
  double lumiVal = 5.0; 
  double lumiErr = 0.039*5.0;
  //  lumiErr = 0.001; 
  double nObs = 61; 
  double sgEffVal = 0.71; 
  double sgEffErr = 0.09; 
  //  sgEffErr = 0.001; 
  double bgVal = 41.7;
  double bgErr = 4.6;
  //  bgErr = 0.001; 

  cout << "simple estimate = " << (nObs - bgVal)/lumiVal/sgEffVal << endl;

  // -- variables, parameters and constraints
  RooRealVar nuisance_b("nuisance_b", "nuisance_b", bgVal, 0, 100); 
  RooRealVar nuisance_b0("nuisance_b0", "nuisance_b central value", bgVal); 
  RooRealVar nuisance_bE("nuisance_bE", "nuisance_b error", bgErr); 

  RooRealVar nuisance_lumi("nuisance_lumi", "nuisance_lumi", lumiVal, 0, 10); 
  RooRealVar nuisance_lumi0("nuisance_lumi0", "nuisance_lumi central value", lumiVal); 
  RooRealVar nuisance_lumiE("nuisance_lumiE", "nuisance_lumi error", lumiErr); 

  RooRealVar nuisance_acc("nuisance_acc", "nuisance_acc", sgEffVal, 0, 1); 
  RooRealVar nuisance_acc0("nuisance_acc0", "nuisance_acc central value", sgEffVal); 
  RooRealVar nuisance_accE("nuisance_accE", "nuisance_acc error", sgEffErr); 

  RooGaussian constraint_b("constraint_b", "constraint_b", nuisance_b, nuisance_b0, nuisance_bE); 
  RooGaussian constraint_lumi("constraint_lumi", "constraint_lumi", nuisance_lumi, nuisance_lumi0, nuisance_lumiE); 
  RooGaussian constraint_acc("constraint_acc", "constraint_acc", nuisance_acc, nuisance_acc0, nuisance_accE); 

  RooRealVar sigma("sigma", "sigma", 0, 100); 
  RooRealVar n("n", "n", nObs, 0, 100); 

  // -- model: nObs = sigma*eff*lumi + bg
//   RooProduct s = RooProduct("s", "s", RooArgSet(sigma, nuisance_lumi, nuisance_acc));
//   RooAddition mean = RooAddition("mean", "mean", RooArgSet(s, nuisance_b));

  RooFormulaVar mean("mean", "mean", "@0*@1*@2 + @3", RooArgList(sigma, nuisance_lumi, nuisance_acc, nuisance_b));

  RooPoisson  pois("pois", "pois", n, mean); 

  RooProdPdf model = RooProdPdf("model", "model", RooArgList(pois, constraint_b, constraint_lumi, constraint_acc)); 

  RooArgSet obs(n); 
  RooArgSet poi(sigma); 
  RooArgSet np(nuisance_b, nuisance_lumi, nuisance_acc); 

  RooDataSet data("data", "data", obs); 
  data.add(obs); 

  cout << "xxxxx > create nll" << endl;
  RooAbsReal *nll = model.createNLL(data);
  
  zone(1);

  //  RooPlot* frame = sigma.frame();
  RooPlot* frame = sigma.frame(Range(0., 12.));
  nll->plotOn(frame, ShiftToZero()); 
  frame->Draw();

  cout << "xxxxx > create pll" << endl;
  RooAbsReal* pll = nll->createProfile(poi);

  pll->plotOn(frame, LineColor(kRed), LineStyle(kDashed));
  frame->Draw();

  RooMinuit mini(*nll);
  mini.minos(poi); //could give no arg list and it will calculate minos errors for all the parameters
  
  RooFitResult *res = mini.save("myResult","My Result");
  
  if (res->status() == 0 ) {
    sigma.Print();
  } else {
    cout << "Likelihood maximization failed" << endl;
  }
  
  cout << "XXXXXXXXXXXXXXXXXXXXXXXXXX second fit XXXXXXXXXXXXXXXXXXXXXXXXXXX" << endl;
  RooFitResult *res2 = model.fitTo(data, Minos(poi), Save(), Hesse(false));
  
  if (res2->status() == 0 ) {
    sigma.Print();
  } else {
    cout << "Likelihood maximization failed" << endl;
  }
    
  TLine l; 
  
  l.DrawLine(sigma.getVal() + sigma.getErrorLo(), 0, sigma.getVal() + sigma.getErrorLo(), 0.5);
  l.DrawLine(sigma.getVal() + sigma.getErrorHi(), 0, sigma.getVal() + sigma.getErrorHi(), 0.5);
  l.DrawLine(0., 0.5, 12., 0.5);

  cout << "xxxxx > nll: " << endl;
  nll->Print("tv");
  cout << "xxxxx > nll_model_data: " << endl;
  nll->getComponents()->find("nll_model_data")->Print("v");
  cout << "xxxxx > nll_model_data_constr: " << endl;
  nll->getComponents()->find("nll_model_data_constr")->Print("v");
  cout << "xxxxx > sigma: " << endl;
  sigma.Print("v");
  cout << "xxxxx > nuisance_b: " << endl;
  nuisance_b.Print("v");
}


// ----------------------------------------------------------------------
void plotHpt::toy8() {

  // based on https://twiki.cern.ch/twiki/bin/view/Main/LearningRoostats
  double lumiVal = 5.0; 
  double lumiErr = 0.039*5.0;
  //  lumiErr = 0.001; 
  double nObs = 61; 
  double sgEffVal = 0.71; 
  double sgEffErr = 0.09; 
  //  sgEffErr = 0.001; 
  double bgVal = 41.7;
  double bgErr = 4.6;
  //  bgErr = 0.001; 

  cout << "simple estimate = " << (nObs - bgVal)/lumiVal/sgEffVal << endl;

  // -- variables, parameters and constraints
  RooRealVar nuisance_b("nuisance_b", "nuisance_b", bgVal, 0, 100); 
  RooRealVar nuisance_b0("nuisance_b0", "nuisance_b central value", bgVal); 
  RooRealVar nuisance_bE("nuisance_bE", "nuisance_b error", bgErr); 

  RooRealVar nuisance_lumi("nuisance_lumi", "nuisance_lumi", lumiVal, 0, 10); 
  RooRealVar nuisance_lumi0("nuisance_lumi0", "nuisance_lumi central value", lumiVal); 
  RooRealVar nuisance_lumiE("nuisance_lumiE", "nuisance_lumi error", lumiErr); 

  RooRealVar nuisance_acc("nuisance_acc", "nuisance_acc", sgEffVal, 0, 1); 
  RooRealVar nuisance_acc0("nuisance_acc0", "nuisance_acc central value", sgEffVal); 
  RooRealVar nuisance_accE("nuisance_accE", "nuisance_acc error", sgEffErr); 

  RooGaussian constraint_b("constraint_b", "constraint_b", nuisance_b, nuisance_b0, nuisance_bE); 
  RooGaussian constraint_lumi("constraint_lumi", "constraint_lumi", nuisance_lumi, nuisance_lumi0, nuisance_lumiE); 
  RooGaussian constraint_acc("constraint_acc", "constraint_acc", nuisance_acc, nuisance_acc0, nuisance_accE); 

  RooRealVar sigma("sigma", "sigma", 0, 100); 
  RooRealVar n("n", "n", nObs, 0, 100); 

  // -- model: nObs = sigma*eff*lumi + bg
  RooProduct s = RooProduct("s", "s", RooArgSet(sigma, nuisance_lumi, nuisance_acc));
  RooAddition mean = RooAddition("mean", "mean", RooArgSet(s, nuisance_b));
  RooPoisson  pois("pois", "pois", n, mean); 

  RooProdPdf model = RooProdPdf("model", "model", RooArgList(pois, constraint_b, constraint_lumi, constraint_acc)); 

  RooArgSet obs(n); 
  RooArgSet poi(sigma); 
  RooArgSet np(nuisance_b, nuisance_lumi, nuisance_acc); 

  RooDataSet data("data", "data", obs); 
  data.add(obs); 

  cout << "xxxxx > create nll" << endl;
  RooAbsReal *nll = model.createNLL(data);
  
  zone(1);

  //RooAbsReal* pll = nll->createProfile(poi);
  cout << "xxxxx > create casted pll" << endl;
  RooProfileLL* pll = dynamic_cast<RooProfileLL*>(nll->createProfile(poi));

  RooFormulaVar p_mu_t("p_mu_t","p_{#mu} 2-sided pll asymp.","TMath::Prob(2*@0,1.)", RooArgList(*pll));

  RooPlot* frame = sigma.frame(Name("plot1"), Range(0., 22.));
  p_mu_t.plotOn(frame, LineColor(kGreen));
  frame->Draw();

  double limit = p_mu_t.findRoot(sigma, 4., 30, 0.05); //for example, to find the 95% limit

  RooOneSidedProfileLL opll("opll","opll",*pll);

  pll->plotOn(frame, LineColor(kRed));
  opll.plotOn(frame, LineColor(kMagenta));

  RooFormulaVar p_mu_q("p_mu_q","p_{#mu} 1-sided pll asymp.","ROOT::Math::normal_cdf_c(sqrt(2*@0),1.)", RooArgList(opll));
  p_mu_q.plotOn(frame, LineColor(kCyan));
  
  frame->GetYaxis()->SetRangeUser(-0.1,1.1);
  frame->Draw();
  TLine l;l.SetLineStyle(2);
  l.DrawLine(0,0.05,22,0.05);

}


// ----------------------------------------------------------------------
void plotHpt::toy9(int nsig, int nbkg) {
  // from https://twiki.cern.ch/twiki/bin/view/RooStats/RooStatsTutorialsJune2013

  RooWorkspace w("w"); 
  w.factory("Exponential:bkg_pdf(x[0,10], a[-0.5,-2,-0.2])");
  w.factory("Gaussian:sig_pdf(x, mass[2], sigma[0.3])");
 
  w.factory("SUM:model(nsig[0,10000]*sig_pdf, nbkg[0,10000]*bkg_pdf)");  // for extended model
 
  RooAbsPdf * pdf = w.pdf("model");
  RooRealVar * x = w.var("x");  // the observable
 
  // set the desired value of signal and background events
  w.var("nsig")->setVal(nsig);
  w.var("nbkg")->setVal(nbkg);
 
  // generate the data

  // use fixed random numbers for reproducibility (use 0 for changing every time)
  RooRandom::randomGenerator()->SetSeed(111);

  // fix number of bins to 50 to plot or to generate data (default is 100 bins) 
  x->setBins(50);

  RooDataSet * data = pdf->generate( *x);  // will generate accordint to total S+B events
  //RooDataSet * data = pdf->generate( *x, AllBinned());  // will generate accordint to total S+B events
  data->SetName("data");
  w.import(*data);

  data->Print(); 

  zone(2,2);
  RooPlot * plot = x->frame(Title("Gaussian Signal over Exponential Background"));
  data->plotOn(plot);
  plot->Draw();

  RooFitResult * r = pdf->fitTo(*data, RooFit::Save(true), RooFit::Minimizer("Minuit2","Migrad"));
  r->Print();

  pdf->plotOn(plot);
  //draw the two separate pdf's
  pdf->plotOn(plot, RooFit::Components("bkg_pdf"), RooFit::LineStyle(kDashed) );
  pdf->plotOn(plot, RooFit::Components("sig_pdf"), RooFit::LineColor(kRed), RooFit::LineStyle(kDashed) );

  pdf->paramOn(plot,Layout(0.5,0.9,0.85));

  plot->Draw();

  RooStats::ModelConfig mc("ModelConfig",&w);
  mc.SetPdf(*pdf);
  mc.SetParametersOfInterest(*w.var("nsig"));
  mc.SetObservables(*w.var("x"));
  // define set of nuisance parameters
  w.defineSet("nuisParams","a,nbkg");

  mc.SetNuisanceParameters(*w.set("nuisParams"));

  // import model in the workspace 
  w.import(mc);

  // write the workspace in the file
  TString fileName = "GausExpModel.root";
  w.writeToFile(fileName,true);
  cout << "model written to file " << fileName << endl;


  // ######################################################################
  // -- Asymptotic calculator Solution 


  // get the modelConfig (S+B) out of the file
  // and create the B model from the S+B model
  ModelConfig*  sbModel = (RooStats::ModelConfig*) w.obj("ModelConfig");
  sbModel->SetName("S+B Model");      
  RooRealVar* poi = (RooRealVar*) sbModel->GetParametersOfInterest()->first();
  poi->setVal(50);  // set POI snapshot in S+B model for expected significance
  sbModel->SetSnapshot(*poi);
  ModelConfig * bModel = (ModelConfig*) sbModel->Clone();
  bModel->SetName("B Model");      
  poi->setVal(0);
  bModel->SetSnapshot( *poi  );

  // create the AsymptoticCalculator from data,alt model, null model
  AsymptoticCalculator  ac(*data, *sbModel, *bModel);
  //T3  ac.SetOneSidedDiscovery(true);  // for one-side discovery test
  //ac.SetPrintLevel(-1);  // to suppress print level 
  
  // run the calculator
  HypoTestResult * asResult = ac.GetHypoTest();
  asResult->Print();

  c0->cd(2);
  HypoTestPlot *aplot = new HypoTestPlot(*asResult);
  aplot->SetLogYaxis(true);
  aplot->Draw();

  std::cout << "\n\nRun now FrequentistCalculator.....\n";

  FrequentistCalculator   fc(*data, *sbModel, *bModel);
  fc.SetToys(2000,500);    // 2000 for null (B) and 500 for alt (S+B) 

  // create the test statistics
  ProfileLikelihoodTestStat profll(*sbModel->GetPdf());
  // use one-sided profile likelihood
  profll.SetOneSidedDiscovery(true);

  // configure  ToyMCSampler and set the test statistics
  ToyMCSampler *toymcs = (ToyMCSampler*)fc.GetTestStatSampler();
  toymcs->SetTestStatistic(&profll);
  
  if (!sbModel->GetPdf()->canBeExtended())
     toymcs->SetNEventsPerToy(1);
 
  // run the test
  HypoTestResult * fqResult = fc.GetHypoTest();
  fqResult->Print();

  // plot test statistic distributions
  c0->cd(3);
  HypoTestPlot *hplot = new HypoTestPlot(*fqResult);
  hplot->SetLogYaxis(true);
  hplot->Draw();

}


// ----------------------------------------------------------------------
void plotHpt::toy10(int nsig0, int nbkg0) {

  RooRealVar     x("x", "x", 0., 10.); // observable
  RooRealVar     a("a", "a", -0.5, -2., -0.2);
  RooExponential bkg_pdf("bgk_pdf", "bgk_pdf", x, a);   


  RooRealVar  mass("mass", "mass", 2.);
  RooRealVar  sigma("sigma", "sigma", 0.3);
  RooGaussian sig_pdf("sig_pdf", "sig_pdf", x, mass, sigma);
    
  RooRealVar nsig("nsig", "nsig", 0., 10000.); 
  RooRealVar nbkg("nbkg", "nbkg", 0., 10000.); 
  RooAddPdf model("model", "model", RooArgList(sig_pdf, bkg_pdf), RooArgList(nsig, nbkg));


  RooAbsPdf * pdf = &model;
 
  // set the desired value of signal and background events
  nsig.setVal(nsig0);
  nbkg.setVal(nbkg0);
 
  // generate the data

  // use fixed random numbers for reproducibility (use 0 for changing every time)
  RooRandom::randomGenerator()->SetSeed(111);

  // fix number of bins to 50 to plot or to generate data (default is 100 bins) 
  x.setBins(50);

  RooDataSet *data = pdf->generate(x);  // will generate accordint to total S+B events
  data->SetName("data");
  data->Print(); 

  // -- plot 0
  zone(2,2);
  RooPlot *plot = x.frame(Title("Gaussian Signal over Exponential Background"));
  data->plotOn(plot);
  plot->Draw();

  RooFitResult *r = pdf->fitTo(*data, RooFit::Save(true), RooFit::Minimizer("Minuit2","Migrad"));
  r->Print();

  pdf->plotOn(plot);
  //draw the two separate pdf's
  pdf->plotOn(plot, RooFit::Components("bkg_pdf"), RooFit::LineStyle(kDashed) );
  pdf->plotOn(plot, RooFit::Components("sig_pdf"), RooFit::LineColor(kRed), RooFit::LineStyle(kDashed) );

  pdf->paramOn(plot,Layout(0.5,0.9,0.85));

  plot->Draw();


  RooWorkspace w("w"); 
  RooStats::ModelConfig mc("ModelConfig", &w);
  mc.SetPdf(*pdf);
  mc.SetParametersOfInterest(nsig);
  mc.SetObservables(x);
  RooArgSet nuisParams(a, nbkg); 

  mc.SetNuisanceParameters(nuisParams);


  // -- plot 1: PLL
  c0->cd(2);
  ProfileLikelihoodCalculator pl(*data, mc);
  pl.SetConfidenceLevel(0.683); // 68% interval
  LikelihoodInterval* interval = pl.GetInterval();
  
  // find the iterval on the first Parameter of Interest
  RooRealVar* firstPOI = (RooRealVar*) mc.GetParametersOfInterest()->first();
  
  double lowerLimit = interval->LowerLimit(*firstPOI);
  double upperLimit = interval->UpperLimit(*firstPOI);
  
  
  cout << "\n68% interval on " <<firstPOI->GetName()<<" is : ["<<
    lowerLimit << ", "<<
    upperLimit <<"] "<<endl;
  
  
  LikelihoodIntervalPlot * liplot = new LikelihoodIntervalPlot(interval);
  liplot->SetRange(0., 150.); 
  liplot->Draw("");  



  // -- Asymptotic significance
  ModelConfig *sbModel = (ModelConfig*)mc.Clone();
  sbModel->SetName("S+B Model");      
  RooRealVar *poi = (RooRealVar*)sbModel->GetParametersOfInterest()->first();
  poi->setVal(50);  // set POI snapshot in S+B model for expected significance
  sbModel->SetSnapshot(*poi);
  
  ModelConfig *bModel = (ModelConfig*)sbModel->Clone();
  bModel->SetName("B Model");      
  poi->setVal(20);
  bModel->SetSnapshot(*poi);

  // create the AsymptoticCalculator from data, alt model, null model
  AsymptoticCalculator  ac(*data, *sbModel, *bModel);
  //T3  ac.SetOneSidedDiscovery(true);  // for one-side discovery test
  //ac.SetPrintLevel(-1);  // to suppress print level 

  // run the calculator
  HypoTestResult * asResult = ac.GetHypoTest();
  asResult->Print();
  
  double expectedP0 = AsymptoticCalculator::GetExpectedPValues(asResult->NullPValue(), asResult->AlternatePValue(), 0, false);
  std::cout << "expected p0 = " << expectedP0 << std::endl;

  
  // --------
  return;
  // --------



  FrequentistCalculator   fc(*data, *sbModel, *bModel);
  fc.SetToys(2000,500);    // 2000 for null (B) and 500 for alt (S+B) 

  // create the test statistics
  ProfileLikelihoodTestStat profll(*sbModel->GetPdf());
  // use one-sided profile likelihood
  profll.SetOneSidedDiscovery(true);

  // configure  ToyMCSampler and set the test statistics
  ToyMCSampler *toymcs = (ToyMCSampler*)fc.GetTestStatSampler();
  toymcs->SetTestStatistic(&profll);
  
  if (!sbModel->GetPdf()->canBeExtended())
    toymcs->SetNEventsPerToy(1);
 
  // run the test
  HypoTestResult * fqResult = fc.GetHypoTest();
  fqResult->Print();

  // plot test statistic distributions
  c0->cd(3);
  HypoTestPlot *hplot = new HypoTestPlot(*fqResult);
  hplot->SetLogYaxis(true);
  hplot->Draw();

  

}

// ----------------------------------------------------------------------
void plotHpt::toy11(int nbg0, double astart) {


  RooRealVar m("m", "m", 70., 180.); 
  RooRealVar a0("a0","a0", astart, 0., 1.) ;
  RooChebychev bgM("bgM","bgM", m, RooArgSet(a0)) ;

  RooDataSet *data0 = bgM.generate(m, nbg0); 

  TH1 *h1 = new TH1D("h1", "h1", 100, 70., 180.);   
  data0->fillHistogram(h1, m); 

  zone(2, 2);
  RooAbsPdf *pdf = &bgM;
  RooFitResult *r0 = pdf->fitTo(*data0, RooFit::Save(true), RooFit::Minimizer("Minuit2","Migrad"));

  RooPlot *plotM = m.frame(Title("mass"));
  data0->plotOn(plotM);
  pdf->plotOn(plotM);
  pdf->paramOn(plotM, Layout(0.5,0.9,0.85));
  plotM->Draw();


  c0->cd(2);
  cout << h1 << endl;
  h1->Fit("pol1");

  RooDataHist hdata("hdata","hdata", m, h1);
  RooFitResult *r1 = pdf->fitTo(hdata, RooFit::Save(true), RooFit::Minimizer("Minuit2","Migrad"));

  c0->cd(3);
  RooPlot *plotMh = m.frame(Title("mass"));
  hdata.plotOn(plotMh);
  pdf->plotOn(plotMh);
  pdf->paramOn(plotMh, Layout(0.5,0.9,0.85));
  plotMh->Draw();

}


// ----------------------------------------------------------------------
void plotHpt::toy12(int nbg0, double astart) {

  readHistograms();

  zone(1,2);
  TH1D *h1 = (TH1D*)fHists["pt_sherpa_hipt"]->Clone("h1");
  normHist(h1, "sherpa", LUMI); 
  h1->SetLineColor(kBlack); 
  gPad->SetLogy(1); 
  h1->SetMaximum(2000.); 
  h1->SetMinimum(0.001); 

  fBg = h1->GetSumOfWeights(); 
  h1->Fit("expo", "r", "", PTLO, PTHI); 
  h1->GetFunction("expo")->SetLineColor(fDS["sherpa"]->fColor); 
  fBgTau  = h1->GetFunction("expo")->GetParameter(1); 
  fBgTauE = h1->GetFunction("expo")->GetParError(1); 
  h1->Draw("hist");
  h1->GetFunction("expo")->Draw("same");
  tl->DrawLatex(0.5, 0.6, Form("tau = %5.4f", fBgTau)); 

  c0->cd(2);
  gPad->SetLogy(1); 

  RooRealVar pt("pt", "pt", 200., 1000.); 
  RooRealVar tau("tau", "tau", fBgTau, -10., 10.); 
  RooExponential sg1Pt("sg1Pt", "signal 1 pT", pt, tau);   

  RooDataHist hdata("hdata","hdata", pt, h1);
  RooFitResult *r1 = sg1Pt.fitTo(hdata, Range(300., 1000.), RooFit::Save(true), RooFit::Minimizer("Minuit2","Migrad"));

  RooPlot *plotPt = pt.frame(Title("pt"));
  hdata.plotOn(plotPt);
  sg1Pt.plotOn(plotPt);
  sg1Pt.paramOn(plotPt, Layout(0.5,0.9,0.85));
  plotPt->Draw();
  
}
